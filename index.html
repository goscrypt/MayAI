<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document AI Bot</title>
    <style>
        body {
            font-family: sans-serif;
            background-color: #f0f2f5;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
        }
        .chat-container {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 600px;
            height: 80vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .chat-box {
            flex-grow: 1;
            padding: 20px;
            overflow-y: auto;
            border-bottom: 1px solid #ddd;
        }
        .message {
            margin-bottom: 15px;
            display: flex;
        }
        .bot-message {
            justify-content: flex-start;
        }
        .user-message {
            justify-content: flex-end;
        }
        .bot-message .content {
            background-color: #e5e5ea;
            color: black;
            border-radius: 10px;
            padding: 10px 15px;
            max-width: 75%;
        }
        .user-message .content {
            background-color: #007bff;
            color: white;
            border-radius: 10px;
            padding: 10px 15px;
            max-width: 75%;
        }
        .input-container {
            display: flex;
            padding: 10px;
            border-top: 1px solid #ddd;
        }
        #chat-input {
            flex-grow: 1;
            border: 1px solid #ccc;
            border-radius: 20px;
            padding: 10px 15px;
            font-size: 16px;
            outline: none;
        }
        #send-button, #voice-button {
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            margin-left: 10px;
            cursor: pointer;
            font-size: 20px;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .file-upload-container {
            padding: 10px;
            text-align: center;
            border-bottom: 1px solid #ddd;
        }
        #file-input {
            display: none;
        }
        .file-label {
            background-color: #28a745;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
        }
        #status {
            margin-top: 10px;
            color: #555;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="file-upload-container">
            <h3>Upload Your Document</h3>
            <label for="file-input" class="file-label">Choose Document</label>
            <input type="file" id="file-input" accept=".pdf,.txt,.doc,.docx">
            <p id="status">Please upload a document to begin.</p>
        </div>
        <div class="chat-box" id="chat-box">
            </div>
        <div class="input-container">
            <input type="text" id="chat-input" placeholder="Ask a question about the document...">
            <button id="voice-button">ðŸŽ¤</button>
            <button id="send-button">â–¶</button>
        </div>
    </div>

<script type="module">
  // Load modules
  import * as pdfjsLib from 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.3.136/build/pdf.min.mjs';
  import { pipeline as loadPipeline } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.0';

  // Set PDF.js worker
  pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.3.136/build/pdf.worker.min.js';

  window.pdfjsLib = pdfjsLib;
  window.transformers = { pipeline: loadPipeline };

  function displayMessage(sender, text) {
    const chatBox = document.getElementById('chat-box');
    const messageDiv = document.createElement('div');
    messageDiv.classList.add('message', sender === 'bot' ? 'bot-message' : 'user-message');
    messageDiv.innerHTML = `<div class="content">${text}</div>`;
    chatBox.appendChild(messageDiv);
    chatBox.scrollTop = chatBox.scrollHeight;
  }

  async function processDocument(file) {
    displayMessage('bot', `Processing "${file.name}"... Please wait.`);
    document.getElementById('status').textContent = `Processing "${file.name}"...`;

    let pipeline;
    try {
 const pipeline = await window.transformers.pipeline('feature-extraction', {
  modelPath: 'https://huggingface.co/Xenova/all-MiniLM-L6-v2/resolve/main/',
  progress_callback: (status) => console.log('Loading:', status)
});



    } catch (err) {
      displayMessage('bot', 'Error loading embedding model. Please check model availability.');
      return;
    }

    let textContent = '';
    if (file.type === 'application/pdf') {
      const url = URL.createObjectURL(file);
      const pdf = await pdfjsLib.getDocument(url).promise;
      for (let i = 1; i <= pdf.numPages; i++) {
        const page = await pdf.getPage(i);
        const text = await page.getTextContent();
        textContent += text.items.map(item => item.str).join(' ');
      }
    } else {
      textContent = await file.text();
    }

    const chunks = textContent.match(/[^.!?]+[.!?]*/g) || [];
    if (chunks.length === 0) {
      displayMessage('bot', 'No readable text found in the document.');
      document.getElementById('status').textContent = 'Failed to process document.';
      return;
    }

    const dbName = 'documentStore';
    const request = indexedDB.open(dbName, 1);

    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      db.createObjectStore('chunks', { keyPath: 'id' });
    };

    request.onsuccess = async (event) => {
      const db = event.target.result;
      const transaction = db.transaction('chunks', 'readwrite');
      const store = transaction.objectStore('chunks');

      displayMessage('bot', `Generating embeddings for ${chunks.length} text chunks...`);

      for (let i = 0; i < chunks.length; i++) {
        const output = await pipeline(chunks[i], { pooling: 'mean', normalize: true });
        store.add({ id: i, text: chunks[i], embedding: output.data });
      }

      transaction.oncomplete = () => {
        db.close();
        displayMessage('bot', 'Document processing complete! You can now ask me questions.');
        document.getElementById('status').textContent = `"${file.name}" is ready.`;
      };
    };

    request.onerror = () => {
      displayMessage('bot', 'Error: Could not access local database.');
    };
  }

  async function handleQuestion(question) {
    displayMessage('user', question);

    const dbName = 'documentStore';
    const request = indexedDB.open(dbName, 1);

    request.onsuccess = async (event) => {
      const db = event.target.result;
      const transaction = db.transaction('chunks', 'readonly');
      const store = transaction.objectStore('chunks');

      const allChunks = await new Promise((resolve, reject) => {
        const getRequest = store.getAll();
        getRequest.onsuccess = () => resolve(getRequest.result);
        getRequest.onerror = () => reject(getRequest.error);
      });

      let pipeline;
      try {
        pipeline = await window.transformers.pipeline('feature-extraction', {
          model: 'Xenova/all-MiniLM-L6-v2',
          // Optional: use modelPath if hosting externally
        });
      } catch (err) {
        displayMessage('bot', 'Error loading embedding model.');
        return;
      }

      const questionEmbedding = (await pipeline(question, { pooling: 'mean', normalize: true })).data;

      let bestMatch = null;
      let maxSimilarity = -1;

      for (const chunk of allChunks) {
        if (chunk.embedding.length !== questionEmbedding.length) continue;
        let dotProduct = 0;
        for (let i = 0; i < questionEmbedding.length; i++) {
          dotProduct += questionEmbedding[i] * chunk.embedding[i];
        }
        if (dotProduct > maxSimilarity) {
          maxSimilarity = dotProduct;
          bestMatch = chunk.text;
        }
      }

      db.close();

      if (bestMatch && maxSimilarity > 0.5) {
        displayMessage('bot', 'Based on the document, here is the most relevant information:');
        displayMessage('bot', bestMatch);
      } else {
        displayMessage('bot', 'I could not find a relevant answer in the document you provided.');
      }
    };

    request.onerror = () => {
      displayMessage('bot', 'Error: Cannot access document database.');
    };
  }

  document.getElementById('file-input').addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (file) processDocument(file);
  });

  document.getElementById('send-button').addEventListener('click', () => {
    const input = document.getElementById('chat-input');
    const question = input.value.trim();
    if (question) {
      handleQuestion(question);
      input.value = '';
    }
  });

  document.getElementById('chat-input').addEventListener('keypress', (event) => {
    if (event.key === 'Enter') {
      document.getElementById('send-button').click();
    }
  });

  const voiceButton = document.getElementById('voice-button');
  if ('webkitSpeechRecognition' in window) {
    const recognition = new webkitSpeechRecognition();
    recognition.continuous = false;
    recognition.interimResults = false;
    recognition.lang = 'en-US';

    voiceButton.addEventListener('click', () => {
      recognition.start();
      voiceButton.textContent = 'ðŸ”´';
    });

    recognition.onresult = (event) => {
      const transcript = event.results[0][0].transcript;
      document.getElementById('chat-input').value = transcript;
      voiceButton.textContent = 'ðŸŽ¤';
      document.getElementById('send-button').click();
    };

    recognition.onend = () => {
      voiceButton.textContent = 'ðŸŽ¤';
    };
  } else {
    voiceButton.style.display = 'none';
  }
</script>


</body>
</html>
