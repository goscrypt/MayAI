<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Local RAG Chatbot (ESM, No Server)</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 2em;
      max-width: 600px;
      margin: auto;
    }
    input, textarea {
      width: 100%;
      margin-bottom: 1em;
    }
    button {
      padding: .5em 1em;
      margin-right: .5em;
    }
    #response {
      white-space: pre-wrap;
      background: #fafafa;
      padding: 1em;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <h2>üß† RAG Chatbot (File:// ‚Äì No Server)</h2>

  <input type="file" id="fileInput" accept=".txt" />
  <textarea id="query" rows="3" placeholder="Ask a question‚Ä¶"></textarea>
  <button id="go">Generate Answer</button>
  <button id="clear">üßπ Clear Cache</button>

  <div id="response">Load a .txt file to get started.</div>

  <!-- everything below runs as an ES module -->
  <script type="module">
    import { pipeline } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@latest/dist/transformers.min.js';

    // state
    let chunks = [];
    let embeddings = [];
    let llm;      // text‚Äêgeneration pipeline

    // split into ~200-word chunks
    function chunkText(text, size = 200) {
      const words = text.split(/\s+/);
      const out = [];
      for (let i = 0; i < words.length; i += size) {
        out.push(words.slice(i, i + size).join(' '));
      }
      return out;
    }

    // get a 1D vector per chunk
    async function embedChunks(chunks) {
      const embed = await pipeline('feature-extraction', 'Xenova/nomic-embed-text-v1');
      const vecs = [];
      for (let c of chunks) {
        const o = await embed(c);
        vecs.push(o[0]);
      }
      return vecs;
    }

    function cosine(a, b) {
      let dot=0, magA=0, magB=0;
      for (let i=0; i<a.length; i++) {
        dot   += a[i]*b[i];
        magA  += a[i]*a[i];
        magB  += b[i]*b[i];
      }
      return dot / (Math.sqrt(magA)*Math.sqrt(magB));
    }

    async function runRAG() {
      const q = document.getElementById('query').value.trim();
      if (!q || embeddings.length === 0) return;

      // embed the query
      const embed = await pipeline('feature-extraction', 'Xenova/nomic-embed-text-v1');
      const qVec = (await embed(q))[0];

      // score & pick top-3
      const scores = embeddings.map((v,i)=>({i, s:cosine(v,qVec)}));
      const top3   = scores.sort((a,b)=>b.s - a.s).slice(0,3).map(o=>o.i);
      const ctx    = top3.map(i=>chunks[i]).join('\n');

      // lazy-load LLM
      if (!llm) {
        llm = await pipeline('text-generation', 'Xenova/distilGPT2');
      }

      const prompt = `Answer based on:\n${ctx}\nQuestion: ${q}`;
      const out    = await llm(prompt, { max_new_tokens: 100 });
      document.getElementById('response').innerText = out[0].generated_text;
    }

    // file upload: chunk, embed, cache
    document.getElementById('fileInput').addEventListener('change', async e => {
      const f = e.target.files[0];
      if (!f) return;
      const txt = await f.text();
      chunks    = chunkText(txt);
      embeddings= await embedChunks(chunks);

      localStorage.setItem('rag_chunks', JSON.stringify(chunks));
      localStorage.setItem('rag_embeddings', JSON.stringify(embeddings));

      document.getElementById('response').innerText = '‚úÖ File loaded & cached.';
    });

    // clear everything
    document.getElementById('clear').onclick = () => {
      localStorage.removeItem('rag_chunks');
      localStorage.removeItem('rag_embeddings');
      chunks = embeddings = [];
      document.getElementById('response').innerText = 'üßπ Cache cleared.';
    };

    document.getElementById('go').onclick = runRAG;

    // on load, restore cache
    window.addEventListener('load', () => {
      const c = localStorage.getItem('rag_chunks');
      const e = localStorage.getItem('rag_embeddings');
      if (c && e) {
        chunks     = JSON.parse(c);
        embeddings = JSON.parse(e);
        document.getElementById('response').innerText = 'üì¶ Cached data loaded.';
      }
    });
  </script>
</body>
</html>
